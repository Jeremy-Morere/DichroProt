#!/bin/bash

#Launch QMMM directory and file for each residus

#Get input name
input=$1
pdb_file=`grep 'PDB' $input | awk '{print $3}'`
prmtop_file=`grep 'PRMTOP' $input | awk '{print $3}'`

N=`wc -l < $pdb_file`
re='^[0-9]+$'           #Use to test if a variable is a integer

#Step 2: Prepare a calculation file for each aromatic residu
#get index of each residu
list_arom=`awk '/#--Aromatic--#/,/#--SS Bridge--#/' $input | tail -n +2 | head -n -1`

at=0

for (( i=1; i<=$N; i++ )); do #i is a mute variable
 at=$(( at + 1 ))
 
 res_typ=`head -n +$at $pdb_file | tail -n +$at | awk '{print $4}'` #Renvoie le type du residu à la ligne $at
 res_num=`head -n +$at $pdb_file | tail -n +$at | awk '{print $5}'` #Renvoie le numero du residu à la ligne $at
 
 #Arrive à l'au on sort de la boucle
 if [ $res_typ = WAT ] ; then break ; fi
 
 if echo $list_arom | tr " " '\n' | grep -F -q -x "$res_num" ; then 
  #If we find a residu

  echo "We find a residu $res_num"
   #Create a forlder and copy useful file
   mkdir R-arom-$res_num
   cp $prmtop_file protein.rst gau_job.tpl R-arom-$res_num
   cp submith.sh R-arom-$res_num

  ##Create amber input
  #Head part
  head -n +41 mdgau-min-tpl > mdgau-min

  #et selon le type de residu on aura plus ou moins de variable.
  #PHE=14, TYR=15, TRP,18
  
  at=$(( at + 3 )) #Retire le backbone
  atom_1=`head -n +$(( at + 1 )) $pdb_file | tail -n +$(( at + 1 )) | awk '{print $2}'`
  atom_2=`head -n +$(( at + 2 )) $pdb_file | tail -n +$(( at + 2 )) | awk '{print $2}'`
  atom_3=`head -n +$(( at + 3 )) $pdb_file | tail -n +$(( at + 3 )) | awk '{print $2}'`
  atom_4=`head -n +$(( at + 4 )) $pdb_file | tail -n +$(( at + 4 )) | awk '{print $2}'`
  atom_5=`head -n +$(( at + 5 )) $pdb_file | tail -n +$(( at + 5 )) | awk '{print $2}'`
  atom_6=`head -n +$(( at + 6 )) $pdb_file | tail -n +$(( at + 6 )) | awk '{print $2}'`
  atom_7=`head -n +$(( at + 7 )) $pdb_file | tail -n +$(( at + 7 )) | awk '{print $2}'`
  atom_8=`head -n +$(( at + 8 )) $pdb_file | tail -n +$(( at + 8 )) | awk '{print $2}'`
  atom_9=`head -n +$(( at + 9 )) $pdb_file | tail -n +$(( at + 9 )) | awk '{print $2}'`
  atom_10=`head -n +$(( at + 10 )) $pdb_file | tail -n +$(( at + 10 )) | awk '{print $2}'`
  atom_11=`head -n +$(( at + 11 )) $pdb_file | tail -n +$(( at + 11 )) | awk '{print $2}'`
  atom_12=`head -n +$(( at + 12 )) $pdb_file | tail -n +$(( at + 12 )) | awk '{print $2}'`
  atom_13=`head -n +$(( at + 13 )) $pdb_file | tail -n +$(( at + 13 )) | awk '{print $2}'`
  atom_14=`head -n +$(( at + 14 )) $pdb_file | tail -n +$(( at + 14 )) | awk '{print $2}'`

  if [ $res_typ = TYR -o $res_typ = TRP ] ; then 
   atom_15=`head -n +$(( at + 15 )) $pdb_file | tail -n +$(( at + 15 )) | awk '{print $2}'`   
   if [ $res_typ = TRP ] ; then
     atom_16=`head -n +$(( at + 16 )) $pdb_file | tail -n +$(( at + 16 )) | awk '{print $2}'`
     atom_17=`head -n +$(( at + 17 )) $pdb_file | tail -n +$(( at + 17 )) | awk '{print $2}'`
     atom_18=`head -n +$(( at + 18 )) $pdb_file | tail -n +$(( at + 18 )) | awk '{print $2}'`
    fi
  fi

  if [ $res_typ = PHE ]; then
   list_qmmm="$atom_1,$atom_2,$atom_3,$atom_4,$atom_5,$atom_6,$atom_7,$atom_8,$atom_9,$atom_10,$atom_11,$atom_12,$atom_13,$atom_14"
at=$(( at + 16 ))
  fi
  if [ $res_typ = TYR ]; then
   list_qmmm="$atom_1,$atom_2,$atom_3,$atom_4,$atom_5,$atom_6,$atom_7,$atom_8,$atom_9,$atom_10,$atom_11,$atom_12,$atom_13,$atom_14,$atom_15"
at=$(( at + 17 ))
  fi
  if [ $res_typ = TRP ]; then
   list_qmmm="$atom_1,$atom_2,$atom_3,$atom_4,$atom_5,$atom_6,$atom_7,$atom_8,$atom_9,$atom_10,$atom_11,$atom_12,$atom_13,$atom_14,$atom_15,$atom_16,$atom_17,$atom_18"
at=$(( at + 20 ))
  fi

  #atom part
  echo "qmmask = '@$list_qmmm'" >> mdgau-min

  #Tail part
  tail -n -12 mdgau-min-tpl>> mdgau-min

  mv mdgau-min R-arom-$res_num

  #Launch the calculation

  cd R-arom-$res_num

  sander -O -i mdgau-min -o test.out -c protein.rst -p $prmtop_file -r test.rst -x test.rst &

  cd ..

 fi
done

#--------------------------------------------------------#
#Step 2: Prepare a calculation file for each sulfide bridge

list_ss=`awk '/#--SS Bridge--#/,/#----#/' $input | tail -n +2 | head -n -1 | tr " " '\n' `
read -a list_ss <<< $list_ss

N_ss=${#list_ss[@]} 

for ((s=0; s<=$(( N_ss - 1 )); s+=2 )); do
 #Les variable atom_1/5 sont utilise comme marqueur de s'ils ont a trouver les résidus
 atom_1=0
 atom_5=0
 at=0

 for  (( i=1; i<=$N; i+=1 )); do
  at=$(( at + 1 ))

  res_typ=`head -n +$at $pdb_file | tail -n +$at | awk '{print $4}'` #Renvoie le type du residu à la ligne $at
  res_num=`head -n +$at $pdb_file | tail -n +$at | awk '{print $5}'` #Renvoie le numero du residu à la ligne $at

  #Arrive à l'au on sort de la boucle
  if [ $res_typ = WAT ] ; then break ; fi
  
  if [ $res_num = ${list_ss[$s]} ] ; then
   at=$(( at + 3 )) #Retire le backbone
   atom_1=`head -n +$(( at + 1 )) $pdb_file | tail -n +$(( at + 1 )) | awk '{print $2}'`
   atom_2=`head -n +$(( at + 2 )) $pdb_file | tail -n +$(( at + 2 )) | awk '{print $2}'`
   atom_3=`head -n +$(( at + 3 )) $pdb_file | tail -n +$(( at + 3 )) | awk '{print $2}'`
   atom_4=`head -n +$(( at + 4 )) $pdb_file | tail -n +$(( at + 4 )) | awk '{print $2}'`
   at=$(( at + 6 ))
  fi
  if [ $res_num = ${list_ss[$(( s + 1 ))]} ] ; then
   at=$(( at + 3 )) #Retire le backbone
   atom_5=`head -n +$(( at + 1 )) $pdb_file | tail -n +$(( at + 1 )) | awk '{print $2}'`
   atom_6=`head -n +$(( at + 2 )) $pdb_file | tail -n +$(( at + 2 )) | awk '{print $2}'`
   atom_7=`head -n +$(( at + 3 )) $pdb_file | tail -n +$(( at + 3 )) | awk '{print $2}'`
   atom_8=`head -n +$(( at + 4 )) $pdb_file | tail -n +$(( at + 4 )) | awk '{print $2}'`
   at=$(( at + 6 ))
  fi
 
  if [ $atom_1 -ne 0 ] && [ $atom_5 -ne 0 ]; then 
   echo "We find a SS-bridge ${list_ss[$s]} ${list_ss[$(( s + 1 ))]}"

   file="R-ss-${list_ss[$s]}-${list_ss[$(( s + 1 ))]}"
   #Create a forlder and copy useful file
   mkdir "$file"
   cp $prmtop_file protein.rst gau_job.tpl $file
   cp submith.sh "$file"

   #Head part
   head -n +41 mdgau-min-tpl > mdgau-min

   #Atom part
   list_qmmm="$atom_1,$atom_2,$atom_3,$atom_4,$atom_5,$atom_6,$atom_7,$atom_8"
   echo "qmmask = '@$list_qmmm'" >> mdgau-min
 
   #Tail part
   tail -n -12 mdgau-min-tpl>> mdgau-min
 
   mv mdgau-min "$file"
 
   cd $file
 
   sander -O -i mdgau-min -o test.out -c protein.rst -p $prmtop_file -r test.rst -x test.rst &
 
   cd ..
   break
  fi

 done 
done

wait

echo "All job finish"
